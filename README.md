# HowtoPracticalTesting

## Test Code를 작성하는 이유
- 변화가 생기는 매순간마다 발생할 수 있는 모든 Case를 고려해야 한다.
- 변화가 생기는 매순간마다 모든 팀원이 동일한 고민을 해야 한다.
- 빠르게 변화하는 소프트웨어의 안정성을 보장할 수 없다.

## Test Code를 작성했을 때 장점
- 자동화 테스트로 비교적 빠른 시간 안에 버그를 발견할 수 있고,
- 수동 테스트에 드는 비용을 크게 절약할 수 있다.
- 소프트웨어의 빠른 변화를 지원한다.
- 팀원들의 집단 지성을 팀 차원의 이익으로 승격시킨다.
- 가까이 보면 느리지만, 멀리 보면 가장 빠르다.

## 테스트 케이스 세분화
- 해피 케이스, 예외 케이스 - 경계값 테스트(범위(이상, 이하, 초과, 미만), 구간, 날짜 등)

## 테스트하기 어려운 영역 구분, 분리
- 관측할 때마다 다른 값에 의존하는 코드는 지양 (현재 날짜/시간, 랜덤값, 전역변수/함수, 사용자 입력 등)
- 외부 세계에 영향을 주는 코드 (표준 출력, 메세지 발송, DB에 기록 등)

## 순수 함수 (pure functions)
- 같은 입력에는 항상 같은 결과
- 외부 세상과 단절된 형태
- 테스트하기 쉬운코드
- 테스트 코드를 작성할 때 순수함수와 같은 형태를 지향해야 함

## 단위 테스트 (Unit Test)
  - 작은 코드 단위를 독립적으로 검증하는 테스트 (클래스 or 메소드)
  - 검증 속도가 빠르고, 안정적
  - 테스트 케이스 세분화
    - 해피케이스, 예외 케이스 (경계값 테스트)
   
## 통합 테스트 (Integration Test)
- 여러 컴포넌트나 여러 모듈이 협력하는 기능을 통합적으로 검증하는 테스트
- 일반적으로 작은 범위의 단위 테스트만으로는 기능 전체의 신뢰성을 보장할 수 없다
- 따라서 단일 기능을 테스트하는 것이 아니라 여러 기능의 연동을 확인
- 대부분의 외부 리소스 (데이터베이스, API, 메시지 큐 등)와의 통신을 포함
- 단위 테스트보다 실행 속도가 느리지만, 시스템의 실제 운영 환경에 가까움
- 주요 테스트 케이스: 서비스 간의 데이터 통신, 데이터베이스와의 통신이 포함된 기능, 외부 API나 서비스와의 통신, 트랜잭션 처리 검증, 동시성 문제가 예상되는 기능의 검증 등

## Test Driven Development (TDD)
- 프로덕션 코드보다 테스트 코드를 먼저 작성하여 테스트가 구현 과정을 주도하도록 하는 방법론
<img width="1004" alt="image" src="https://github.com/angelSooho/HowtoPracticalTesting/assets/26915908/dc79e322-1403-416a-a0fb-899d1cbe5432">

### 선 기능 구현 후, 테스트 작성
- 테스트 자체의 누락 가능성
- 특정 테스트 케이스 (ex) 해피 케이스)만 검증할 가능성
- 잘못된 구현을 다소 늦게 발견할 가능성

### TDD 장점
- 복잡도가 낮은(유연하며 유지보수가 쉬운), 테스트 가능한 코드로 구현할 수 있게 한다.
- 쉽게 발견하기 어려운 엣지(Edge) 케이스를 놓치지 않게 해준다.
- 구현에 대한 빠른 피드백을 받을 수 있다.
- 과감한 리팩토링이 가능해진다.

## Behavior Driven Development (BDD)
- TDD에서 파생된 개발 방법
- 함수 단위의 테스트에 집중하기보다, 시나리오에 기반한 테스트케이스(TC) 자체에 집중하여 테스트한다.
- 개발자가 아닌 사람이 봐도 이해할 수 있을 정도의 추상화 수준(레벨)을 권장
- ### Given / When / Then
  - Given : 시나리오 진행에 필요한 모든 준비 과정 (객체, 값, 상태 등)
  - When : 시나리오 행동 진행
  - Then : 시나리오 진행에 대한 결과 명시, 검증
 
## Layered Architecture
 
### Persistence Layer
- Data Access의 역할
- 비즈니스 가공 로직이 포함되어서는 안 된다. Data에 대한 CRUD에만 집중한 레이어

### Business Layer
- 비즈니스 로직을 구현하는 역할
- Persistence Layer와의 상호작용(Data를 읽고 쓰는 행위)을 통해 비즈니스 로직을 전개시킨다.
- 트랜잭션을 보장해야 한다.

### Presentation Layer 
- 외부 세계의 요청을 가장 먼저 받는 계층
- 파라미터에 대한 최소한의 검증을 수행한다

## Mock, Mockito
- MockMvc
  - Mock(가짜) 객체를 사용해 스프링 MVC 동작을 재현할 수 있는 테스트 프레임워크
- Test Double
  - Dummy : 아무 것도 하지 않는 깡통 객체
  - Fake : 단순한 형태로 동일한 기능은 수행하나, 프로덕션에서 쓰기에는 부족한 객체 (ex. FakeRepository)
  - Stub : 테스트에서 요청한 것에 대해 미리 준비한 결과를 제공하는 객체. 그 외에는 응답하지 않는다. **상태 검증 (State Verification)**
  - Spy : Stub이면서 호출된 내용을 기록하여 보여줄 수 있는 객체. 일부는 실제 객체처럼 동작시키고 일부만 Stubbing할 수 있다.
  - Mock : 행위에 대한 기대를 명세하고, 그에 따라 동작하도록 만들어진 객체 **행위 검증 (Behavior Verification)**
 
## 좋은 테스트 코드를 작성하기 위한 팁
- 한 문단에 한 주제
- 코드를 완벽하게 제어
- 테스트 환경의 독립성을 보장
- 테스트 간 독립성을 보장
- 한 눈에 들어오는 Test Fixture 구성
  - Fixture : 고정물, 고정되어 있는 물체
  - 테스트를 위해 원하는 상태로 고정시킨 일련의 객체
 
## @ParameterizedTest
- 다양한 입력 값과 예상되는 출력 값의 쌍에 대해 테스트를 수행
- @ValueSource, @EnumSource, @CsvSource 등의 애너테이션을 사용하여 테스트에 필요한 인자들을 제공
- 코드의 중복을 방지하면서 다양한 시나리오를 쉽게 테스트
- 테스트 케이스의 확장이 간편

## @DynamicTest
- 런타임에 동적으로 테스트를 생성하고 실행하는 기능을 제공
- 정적 테스트 메소드와는 달리 컴파일 타임에 미리 정의된 테스트 케이스가 아닌, 런타임에 동적으로 생성된 테스트 케이스를 실행
- @DynamicTest를 사용하려면 @TestFactory 어노테이션을 사용하여 테스트 팩토리 메소드를 정의. 이 메소드는 Stream, Collection, Iterable 또는 Iterator 형태의 DynamicTest 객체를 반환
- @DynamicTest 메소드는 직접 호출되지 않으므로, @BeforeEach 또는 @AfterEach 어노테이션과 함께 사용X

## 테스트 환경 통합
- 테스트 수행도 비용이다. 환경 통합

## 학습 테스트
- 잘 모르는 기능, 라이브러리, 프레임워크를 학습하기 위해 작성하는 테스트
- 여러 테스트 케이스를 스스로 정의하고 검증하는 과정을 통해 보다 구체적인 동작과 기능을 학습할 수 있다.
- 관련 문서만 읽는 것보다 훨씬 재미있게 학습할 수 있다.

